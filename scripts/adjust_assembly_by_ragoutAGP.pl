#!/usr/bin/perl
use warnings;
use strict;
use Getopt::Long;

##############################################################
#  script: adjust_assembly_by_ragoutAGP.pl
#  author: Jia-Xing Yue (GitHub ID: yjx1217)
#  last edited: 2017.06.17
#  description: adjust gap size for Ragout output
#  example: perl adjust_assembly_by_ragoutAGP.pl -i raw_ragout_assembly.fa.gz -p prefix -a prefix_scaffolds.agp -g 5000
##############################################################

my ($input, $agp, $gap_size, $prefix);
$gap_size = 5000;
GetOptions('input|i:s' => \$input, # raw ragout assembly
           'agp|a:s' => \$agp, # agp file generated by ragout
	   'gap|g:s' => \$gap_size, # gap size
           'prefix|p:s' => \$prefix); # file name prefix for output files

my $input_fh = read_file($input);
my @input = ();
my %input = ();
parse_fasta_file($input_fh, \@input, \%input);
close $input_fh;


my $agp_fh = read_file($agp);
my %agp = parse_agp_file($agp_fh);
close $agp_fh;

my $assembly_output = "$prefix.ragout.fa";
my $assembly_output_fh = write_file($assembly_output);

my $agp_output = "$prefix.ragout.agp";
my $agp_output_fh = write_file($agp_output);
print $agp_output_fh "##agp-version  2.0\n";
print $agp_output_fh "#ASSEMBLY NAME: $prefix\n";
print $agp_output_fh "#DESCRIPTION: Pseudochromosome assembly\n";
print $agp_output_fh "#PROGRAM: Ragout v2.0 with gap resized to $gap_size bp\n";

my %used_contigs = ();
foreach my $chr (sort keys %agp) {
    my ($new_chr) = ($chr =~ /^chr_(\S+)/);
    print $assembly_output_fh ">$new_chr\n";
    my $chr_offset = 0;
    my $part_index = 0;
    foreach my $part_record (@{$agp{$chr}}) {
	$part_index++;
	my $part_seq = "";
	my @part_record = split ':', $part_record;
	if ($part_record[0] ne 'N') {
	    my $contig_id = $part_record[1];
	    my $contig_start = $part_record[2];
	    my $contig_end = $part_record[3];
	    my $contig_orientation = $part_record[4];
	    $part_seq = $input{$contig_id};
	    $used_contigs{$contig_id} = 1;
	    if ($contig_orientation eq '-') {
		$part_seq = revcom($part_seq);
	    }
	    my $chr_start = $contig_start + $chr_offset;
	    my $chr_end = $chr_start + $contig_end - $contig_start;
	    $chr_offset = $chr_end;
	    print $agp_output_fh "$new_chr\t$chr_start\t$chr_end\t$part_index\t$part_record[0]\t$contig_id\t$contig_start\t$contig_end\t$contig_orientation\n";
	} else {
	    $part_seq = 'N' x $gap_size;
	    my $chr_start = 1 + $chr_offset;
	    my $chr_end = $chr_start + $gap_size - 1;
	    $chr_offset = $chr_end;
	    print $agp_output_fh "$new_chr\t$chr_start\t$chr_end\t$part_index\t$part_record[0]\t$gap_size\tscaffold\tyes\t\n";
	}

	print $assembly_output_fh "$part_seq";
    }
    print $assembly_output_fh "\n";
}



foreach my $contig_id (@input) {
    if (not exists $used_contigs{$contig_id}) {
	print $assembly_output_fh ">$contig_id\n$input{$contig_id}\n";
    }
}

close $assembly_output_fh;
close $agp_output_fh;




sub read_file {
    my $file = shift @_;
    my $fh;
    if ($file =~ /\.gz$/) {
        open($fh, "gunzip -c $file |") or die "can't open pipe to $file";
    } else {
        open($fh, $file) or die "can't open $file";
    }
    return $fh;
}

sub write_file {
    my $file = shift @_;
    my $fh;
    if ($file =~ /\.gz$/) {
        open($fh, "| gzip -c >$file") or die "can't open $file\n";
    } else {
        open($fh, ">$file") or die "can't open $file\n";
    }
    return $fh;
}  



sub parse_fasta_file {
    my ($fh, $seq_arrayref, $seq_hashref) = @_;
    my $seq_name = "";
    while (<$fh>) {
        chomp;
        if (/^\s*$/) {
            next;
        } elsif (/^\s*\#/) {
            next;
        } elsif (/^>(\S+)/) {
            $seq_name = $1;
	    push @$seq_arrayref, $seq_name;
            $$seq_hashref{$seq_name} = "";
        } else {
            $$seq_hashref{$seq_name} .= $_;
        }
    }
}

sub revcom {
    my $seq = shift @_;
    my $seq_revcom = reverse $seq;
    $seq_revcom =~ tr/ATGCNatgcn/TACGNtacgn/;
    return $seq_revcom;
}

sub parse_agp_file {
    my %agp = ();
    while (<$agp_fh>) {
	chomp;
	/^#/ and next;
	/^\s*$/ and next;
	my ($obj_id, $obj_start, $obj_end, $part_index, $part_type, $part_id, $part_start, $part_end, $part_orientation) = split /\t/, $_;
	if (exists $agp{$obj_id}) {
	    if ($part_type eq 'W') {
		push @{$agp{$obj_id}}, "$part_type:$part_id:$part_start:$part_end:$part_orientation";
	    } elsif ($part_type eq 'N') {
		push @{$agp{$obj_id}}, "N:$gap_size";
	    }
	} else {
	    if ($part_type eq 'W') {
		@{$agp{$obj_id}} = "$part_type:$part_id:$part_start:$part_end:$part_orientation";
            } elsif ($part_type eq 'N') {
		@{$agp{$obj_id}} = "$part_type:$gap_size";
            }
	}
    }
    return %agp;
}

